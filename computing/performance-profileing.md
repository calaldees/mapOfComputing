Performance Profiling
=====================

* [Flame Graphs](https://www.brendangregg.com/flamegraphs.html)
    * > Flame graphs are a visualization of hierarchical data, created to visualize stack traces of profiled software so that the most frequent code-paths to be identified quickly and accurately.
    * [pyspy](https://github.com/benfred/py-spy?tab=readme-ov-file#how-do-i-run-py-spy-in-docker)
    * https://roman.pt/posts/python-performance-profiling/
    * Pyspy live https://www.youtube.com/watch?v=p8s2fzqA07s

* Instrumentation
    * TODO define

* [All my favorite tracing tools: eBPF, QEMU, Perfetto, new ones I built and more](https://thume.ca/2023/12/02/tracing-methods/)
    * Aewsome animated gifs and real examples

* [Counting cycles and instructions on the Apple M1 processor](https://lemire.me/blog/2021/03/24/counting-cycles-and-instructions-on-the-apple-m1-processor/)
    * How do you measure performance?
        * modern process's just overclock to run faster
        * [[branch-prediction]] takes power
    * What is you wanted to measure page useaage?

* [FunctionTrace](https://functiontrace.com/) - A graphical Python profiler that provides a clear view of your application's execution while being both low-overhead and easy to use.

* [Understanding Request Latency with Profiling](https://richardstartin.github.io/posts/wallclock-profiler) [[latency]]

Algorithms
Platforms

Real data vs theoretical best/worst cast

Data throughput, response times.

* [GFXBench](https://gfxbench.com/result.jsp)

* [shish/eventtracer-py](https://github.com/shish/eventtracer-py)
    * Python profiler that outputs in a format that can be loaded by chrome dev tools for visulisations
* [timeit](https://docs.python.org/3/library/timeit.html)

[//begin]: # "Autogenerated link references for markdown compatibility"
[branch-prediction]: branch-prediction.md "Branch Prediction"
[latency]: latency.md "Latency"
[//end]: # "Autogenerated link references"
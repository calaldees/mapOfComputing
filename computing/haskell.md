Haskell
=======

* [haskell.org](https://www.haskell.org/)
    * [repl.it/haskell](https://repl.it/site/blog/haskell) Live browser haskell
    * [realworldhaskell](http://book.realworldhaskell.org/)
    * [Why Haskell is our first choice for building production software systems](https://www.foxhound.systems/blog/why-haskell-for-production/)
    * [Haskell is a Bad Programming Language](https://blog.shitiomatic.tech/post/haskell-is-a-bad-programming-language/)
        * > Haskell is “too hard for people to learn” ... If people can pick up F#, Scala and Clojure, all with their own brand of weirdness, both in syntax and environment while being functional programming languages, I don’t really see how this statement holds any water.
    * [Haskell: The Bad Parts, part 2](https://www.snoyman.com/blog/2020/11/haskell-bad-parts-2/)
* [Why Co–Star uses Haskell](https://www.costarastrology.com/why-haskell)

* [Haskell School of Music](https://www.cs.yale.edu/homes/hudak/Papers/HSoM.pdf)
    * Whole book about functional music creation

* [snake-fury](https://github.com/lsmor/snake-fury)
    * > Welcome to snake-fury: the Haskell challenge for beginners. This challenge aims to provide a learning path for people willing to learn Haskell further than basic recursion exercises by implementing the snake game in Haskell. Snake-fury's pedagogical approach is based on two legs:
        * snake-fury isn't a tutorial but a challenge.
        * snake-fury is focused on learning by refactoring, not by example.

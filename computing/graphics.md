Graphics
========

* [[3D]]
* [[Animation]]
* [[Dither]]
* [[graphics-evolution]]
* [[OpenGL]]
* [[Timelaps]]
* [[Vector]]
* [[pixel-art]]
* [[graphics-hardware]]
* [[raytracing]]
* [[pallet-cycling]]

* [Scratchapixel 4.0](https://www.scratchapixel.com/) Computer Graphics Lessons and Books (free)
    * > Teaching computer graphics programming to regular folks. Original content written by professionals with years of field experience. We dive straight into code, dissect equations, avoid fancy jargon and external libraries. Explained in plain English. Free.

* [Meta Uses Khronos Open Standards in New Intermediate Graphics Library](https://www.khronos.org/blog/meta-uses-khronos-open-standards-in-new-intermediate-graphics-library)

* [Beginning FPGA Graphics](https://projectf.io/posts/fpga-graphics/)
    * Software for a graphics controller explained with drawing flags

* [A Pixel is not A Little Square](http://alvyray.com/Memos/CG/Microsoft/6_pixel.pdf)
* [Computer Graphics from Scratch](https://gabrielgambetta.com/computer-graphics-from-scratch/) book
    * Ray-tracing
    * Rasterisation
    * [Filled Triangles](https://gabrielgambetta.com/computer-graphics-from-scratch/07-filled-triangles.html)

* More Filled Triangles
    * [Software Rasterization Algorithms for Filling Triangles](http://www.sunshine2k.de/coding/java/TriangleRasterization/TriangleRasterization.html)
* [High-performance 2D graphics rendering on the CPU using sparse strips](https://github.com/LaurenzV/master-thesis/blob/main/main.pdf) [HN Comments](https://news.ycombinator.com/item?id=45881568)
* [Blaze](https://gasiulis.name/parallel-rasterization-on-cpu/)
    * a CPU-based, multithreaded vector graphics rasterizer
    * > Traditional scanline rasterizers follow path outline, update some sort of edge list for each scanline, then convert this edge list to arrays of spans for final composition on the destination surface.
      > While there are methods to optimize this process quite well, it suffers from being bound to a single CPU core. The biggest contributor to the problem is the fact that any segment in the path can affect how it covers any particular pixel. You cannot examine a few segments of an entire path and decide if pixel X is covered or not, like it is with triangle meshes, for example.
       > For this reason it is a challenge to find a way to distribute workload equally across multiple threads.


* [Worldsheet: Wrapping the World in a 3D Sheet for View Synthesis from a Single Image](https://worldsheet.github.io/)
    * 2d image + bump map -> 3d scene

* [Watercolor Maps](http://maps.stamen.com/watercolor/)



[//begin]: # "Autogenerated link references for markdown compatibility"
[3D]: 3d.md "3D"
[Animation]: animation.md "Animation"
[Dither]: dither.md "dither"
[graphics-evolution]: graphics-evolution.md "Evolution of Computer Graphics"
[OpenGL]: opengl.md "OpenGL"
[Timelaps]: timelaps.md "Timelaps"
[Vector]: vector.md "Vector Graphics"
[pixel-art]: pixel-art.md "pixel-art"
[graphics-hardware]: graphics-hardware.md "Graphics Hardware"
[raytracing]: raytracing.md "Raytracing"
[pallet-cycling]: pallet-cycling.md "pallet-cycling"
[//end]: # "Autogenerated link references"
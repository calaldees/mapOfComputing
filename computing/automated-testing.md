Automated Testing
=================

Should we be moving away from testing and more to [[monitoring]]?

* [Thoughts on Testing](https://www.brandons.me/blog/thoughts-on-testing)
    * Maybe we should not be writing so many tests - which are the tests that have value
    * Test business logic
    * Mocking is often complex and fragile

* [[testing]]

happy path and nasty path

As limited scope as possible with test data


Frontend Tests
--------------

* Selenium
    * https://github.com/mherrmann/helium
* [Cypress](https://www.cypress.io/)
https://github.com/syscolabs/kasaya

* https://playwright.dev/
* https://testcafe.io/


UnitTests
---------

* [Favor real dependencies for unit testing](https://stackoverflow.blog/2022/01/03/favor-real-dependencies-for-unit-testing/) Mark Seeman
    * Which dependencies should be present in your code base? This article suggests an answer to that question.
    * Mocks may not be needed - there are other strategies

### DocTests

* [my doctest example with error](https://github.com/calaldees/TeachProgramming/blob/master/teachprogramming/static/projects/doctest_example.py)
* [Solving Algorithmic Problems in Python with Pytest](https://adamj.eu/tech/2019/04/21/solving-algorithmic-problems-in-python-with-pytest/)

* [Precisely: better assertions for Python tests](https://github.com/mwilliamson/python-precisely)

* [Doctest](https://hughjonesd.github.io/doctest/) in R?


### Property based tests

Not specifying the inputs and letting the test framework fuzz the test

* [Getting Started With Property-Based Testing in Python With Hypothesis and Pytest](https://semaphoreci.com/blog/property-based-testing-python-hypothesis-pytest)


Test Driven Development TDD
---

> 'Test-driven development is double-entry bookkeeping.' 
<sub>@unclebobmartin</sub>

(expanding string calculator requirements example)
https://osherove.com/tdd-kata-1/



https://axiom.ai/ - AI based browser testing

* [retrospective: An Axiomatic Basis for Computer Programming](https://dl.acm.org/doi/pdf/10.1145/1562764.1562779)
    * > Verification   technology   can only work against errors that have been accurately  specified,  with  as  much  ac-curacy   and   attention   to   detail   as   all other aspects of the programming task.
    * software verification: Automated tests and [[formal-specification]]

* [pynguin](https://github.com/se2p/pynguin) - The PYthoN General Unit Test geNerator is a test-generation tool for Python
    * humm .. unsure of how effective automatically generated tests are - investigate

* Contact Testing
    * [pact.io](https://pact.io/)
    * Say goodbye to end-to-end testing
    * Testing microservices shouldn't involve setting up complex end-to-end test environments, creating lengthy integration suites and managing test data. Stop wasting time, and start releasing.

* [NaNofuzz: A Usable Tool for Automatic Test Generation](https://cmumatt.github.io/assets/NaNofuzz_2023.pdf)

Python libs
-----------

* [syrupy](https://github.com/tophat/syrupy) a replacement for snapshot tests
* [Tavern](https://tavern.readthedocs.io/en/latest/basics.html)
    * Specify tests in yaml as full flows
    * I'm unsure if a whole new yaml spec is needed. Could you not write these as python?
    * Most flows only need the same subset of features - get url - take params out of return - make another request - check some stuff has changed. The yaml is language agnostic

[//begin]: # "Autogenerated link references for markdown compatibility"
[monitoring]: monitoring.md "Monitoring"
[testing]: testing.md "Testing"
[formal-specification]: formal-specification.md "Formal Specification"
[//end]: # "Autogenerated link references"
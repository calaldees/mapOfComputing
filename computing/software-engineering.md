Software Engineering
====================

* [[Agile]]
* [[CV]]
* [[Code Review]]
* [[Project Management]]
* [[rfc]]
* [[testing]]
* [[automated-testing]]
* [[Software Industry]]
* [[Technical Dept]]
* [[hypothesis-driven-development]]
* [[job-applications]]
* [[software-engineering-skills]]
* [[tech-dept]]
* [[microservice]]
* [[server-infrastructure]]

Consider ideas about industry software engineering.
Could be combined with the notes in my blog repo?

I was looking at case studies for [[telematry]] and was thinking of practical uses

* [Dev Concepts](https://dev-concepts.dev/) Book (pre-order)

* [new codebase, who dis? (How to Join a Team and Learn a Codebase)](https://www.samueltaylor.org/articles/how-to-learn-a-codebase.html)
    * Setup dev environment
    * Get overview of architecture
* [Heuristics for Effective Software Development: A continuously evolving list](https://holub.com/heuristics-for-effective-software-development-a-continuously-evolving-list/)
    * Without psychological safety, respect, and trust, none of the following is possible.
    * Process exists in service of people; the people come first.
    * The best ways to work are collaborative. Negotiation is not collaboration
    * Welcome change (you cant be rigid and agile)
* [Full Cycle Developers at Netflix — Operate What You Build](https://netflixtechblog.com/full-cycle-developers-at-netflix-a08c31f83249)
* [Planning & estimating large-scale software projects](https://tomrussell.co.uk/writing/2021/07/19/estimating-large-scale-software-projects.html)
    * A guide and formula
* [Engineering productivity can be measured - just not how you'd expect ](https://www.okayhq.com/blog/engineering-productivity-can-be-measured) Antoine Boulanger 2021
    * AMAZING article
    * Mistake 1 - measure approximations of output
        * Developers game the system - seniors get board of the games
    * Mistake 2 - Measure nothing as its too complex
        * Long term motivation suffers as nothing matters
        * This system rewards charisma
    * The Solution: Measure Blockers at the Team Level 
        * Blockers
            * Quality of developer tools
            * Frequency and quality of internal activities (like meetings or code reviews)
            * Focused maker time (free from disruptive meetings)
            * Easy access to documentation
            * Psychological safety on the team
            * Work-life balance
            * Presence of other high-performers
            * A fair system of rewards
        * Metrics
            * How much free, uninterrupted time does an engineer have to code?
            * How long is an engineer waiting on a response from another engineer's review?
            * How often do dev tools get in the way instead of helping accelerate work? 
            * How often are engineers required to context switch, preventing deep work?
            * How often do engineers receive pages outside of business hours, interrupting their sleep or family life?
        * An engineering leader exists to enable their team to achieve their goals
* Metrics
    * [Applying Advanced Agile Metrics (AAAM)](https://actineo.xyz/training/advanced-agile-courses/applying-advanced-agile-metrics/) course
* SPACE
    * [The SPACE of Developer Productivity](https://queue.acm.org/detail.cfm?id=3454124) - There's more to it than you think.
        * Measuring productivity in multi dimenisons
        * SPACE (5 dimensions)
            * satisfaction and well-being; 
            * performance; 
            * activity; 
            * communication and collaboration; 
            * and efficiency and flow. 
    * [The SPACE of Developer Productivity](https://cacm.acm.org/magazines/2021/6/252825-the-space-of-developer-productivity/fulltext)
        * Lists myths of software productivity
* [How to hire senior developers: Give them more autonomy](https://hiringengineersbook.com/post/autonomy/)
    * (insightful article about the value of code and the value of developers) - code is the manifestation of the the understanding of a problem
    * Your source code is worthless
    * The main value of a software company is the mapping of source code and problem space in the developer’s heads
    * developers should be given more responsibility and regarded as permanent assets to the company.
    * If you’re in a management position, you need to realize that development is mainly decision making, which of course only works if you’re given the necessary autonomy to make those decisions.

* [What I’ve Learned in 45 Years in the Software Industry](https://www.bti360.com/what-ive-learned-in-45-years-in-the-software-industry/)

* [What Silicon Valley "Gets" about Software Engineers that Traditional Companies Do Not](https://blog.pragmaticengineer.com/what-silicon-valley-gets-right-on-software-engineers/)
    * > "SV-like" companies think of engineers as value generators, and creative problem solvers. Traditional companies think of them as factory workers.
    1. Autonomy for software engineers
        * > The expectation from developers at traditional companies is to complete assigned work. At SV-like companies, it's to solve problems that the business has.
    2. Curious problem solvers, not mindless resources
        * > In practice, a motivated engineer easily makes multiple times the impact of a "factory worker" who is just told what to do
    3. Internal data, code, and documentation transparency
    4. Exposure to the business and to business metrics
        * > In contrast, traditional companies often make it impossible for developers to interact with the rest of the business
    5. Engineer-to-engineer comms over triangle-communication
        * > Traditional companies will encourage hierarchical communication
    6. Investing in a less frustrating developer experience
        * > While it might sound counter-intuitive to hire software engineers who only focus on other software engineers working faster: at many places, it's not. It's a great return that helps these companies move faster, and developers stay happier.
    7. Higher leverage --> higher {autonomy, pay}

* [Software development topics I've changed my mind on after 6 years in the industry](https://chriskiehl.com/article/thoughts-after-6-years)
    * Bad code can be written in any paradigm
    * Clever code isn't usually good code. Clarity trumps all other concerns
    * Despite being called "engineers," most decision are pure cargo-cult with no backing analysis, data, or numbers
    * Code coverage has absolutely nothing to do with code quality

* [Maximizing Developer Effectiveness](https://martinfowler.com/articles/developer-effectiveness.html) Martin Fowler 2021
    * Technology is constantly becoming smarter and more powerful. I often observe that as these technologies are introduced an organization’s productivity instead of improving has reduced. This is because the technology has increased complexities and cognitive overhead to the developer, reducing their effectiveness.
    * TODO: read this mand make notes

* [Meta-Design: A Manifesto for End-User Development](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.68.6315&rep=rep1&type=pdf)
    * The seeding, evolutionary growth, and reseeding (SER) process model

* [Developers spend most of their time figuring the system out](https://blog.feenk.com/developers-spend-most-of-their-time-figuri-7aj1ocjhe765vvlln8qqbuhto/)
    * Code is just data - when we make decisions about code, it's kind of data-science
    * We should never make decisions without knowing the 
* [7 behaviours to avoid in a software architecture role](https://www.danielwatts.info/post/7-behaviours-to-avoid-software-architect/)


* [ARCHITECTURE.md](https://matklad.github.io//2021/02/06/ARCHITECTURE.md.html)
    * Consider an ARCHITECTURE.md to describe the system
* [On navigating a large codebase](https://blog.royalsloth.eu/posts/on-navigating-a-large-codebase/)
* [The Half Life of Code](https://sandimetz.com/blog/2017/6/1/the-half-life-of-code)
* [Why does it take so long to build software?](https://www.simplethread.com/why-does-it-take-so-long-to-build-software/) complexity, software design, thoughts


* [The Importance of Humility in Software Development](http://humbletoolsmith.com/2020/08/10/the-importance-of-humility-in-software-development/)
    * Dijkstra 1972
        1. The use of abstraction to make programs intellectually manageable
        2. Developing correctness proofs alongside the software
        3. Approaching the task of software development as humble programmers
            * > brainpower is by far our scarcest resource
        * > The competent programmer is fully aware of the strictly limited size of his own skull; therefore he approaches the programming task in full humility

* [Programming, Motherfucker](http://programming-motherfucker.com/) - Do you speak it?

* [Drunk Post: Things I've learned as a Sr Engineer](https://old.reddit.com/r/ExperiencedDevs/comments/nmodyl/drunk_post_things_ive_learned_as_a_sr_engineer/)
    * The best way I've advanced my career is by changing companies.
    * Technology stacks don't really matter because there are like 15 basic patterns of software engineering in my field that apply. I work in data so it's not going to be the same as webdev or embedded. But all fields have about 10-20 core principles and the tech stack is just trying to make those things easier, so don't fret overit.
    * I've made some good, lifelong friends at companies I've worked with. I don't need to make that a requirement of every place I work. I've been perfectly happy working at places where I didn't form friendships with my coworkers and I've been unhappy at places where I made some great friends.
    * If I'm awaken at 2am from being on-call for more than once per quarter, then something is seriously wrong and I will either fix it or quit.
    * Good code is code that can be understood by a junior engineer. Great code can be understood by a first year CS freshman. The best code is no code at all.
    * The most underrated skill to learn as an engineer is how to document.
    * Related to above, writing good proposals for changes is a great skill.
    * The older I get, the more I appreciate dynamic languages. Fuck, I said it. Fight me.
    * If I ever find myself thinking I'm the smartest person in the room, it's time to leave.
    * We should hire more interns, they're awesome. Those energetic little fucks with their ideas. Even better when they can question or criticize something. I love interns.
    * Speaking of titles: early in your career, title changes up are nice. Junior to Mid. Mid to Senior. Senior to Lead. Later in your career, title changes down are nice. That way, you can get the same compensation but then get an increase when you're promoted. In other words, early in your career (<10 years), title changes UP are good because it lets you grow your skills and responsibilities. Later, title changes down are nice because it lets you grow your salary.
    * I know enough about security to know that I don't know shit about security.
    * Being a good engineer means knowing best practices. Being a senior engineer means knowing when to break best practices.
    * If people are trying to assign blame to a bug or outage, it's time to move on.
    * It's not important to do what I like. It's more important to do what I don't hate.
* [High-Performance-Organizations-Reading-List](https://github.com/pdfernhout/High-Performance-Organizations-Reading-List)
    * Amazing book summarys of LOADS of classic books
    * Not just computing - talks about organisation/societal structure
    * Some damning books about why agile is bad

* [MacPaint and QuickDraw Source Code](https://computerhistory.org/blog/macpaint-and-quickdraw-source-code/)
    * Measuring _Lines of Code_ is a bad metric for programmers #metrics #history

* Lock-in
    * [Don't get locked up into avoiding lock-in](https://martinfowler.com/articles/oss-lockin.html)
        * Vendor lock-in
        * Product lock-in
        * Version lock-in
        * Architecture lock-in
        * Platform lock-in
        * Skills lock-in
        * Legal lock-in
        * Mental lock-in


[//begin]: # "Autogenerated link references for markdown compatibility"
[Agile]: agile.md "Agile"
[CV]: cv.md "Carrers and Resume"
[Code Review]: code-review.md "Code Review"
[Project Management]: project-management.md "Project Management"
[rfc]: rfc.md "rfc"
[testing]: testing.md "Testing"
[automated-testing]: automated-testing.md "Automated Testing"
[Software Industry]: software-Industry.md "Software Industry"
[Technical Dept]: technical-dept.md "Technical Dept"
[hypothesis-driven-development]: hypothesis-driven-development.md "Hypothesis Driven Development"
[job-applications]: job-applications.md "Job Applications and Interviews"
[software-engineering-skills]: software-engineering-skills.md "Software Engineer Skills"
[tech-dept]: tech-dept.md "Tech Dept"
[microservice]: microservice.md "MicroService"
[server-infrastructure]: server-infrastructure.md "Server Infrastructure"
[//end]: # "Autogenerated link references"
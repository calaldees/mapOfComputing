Operating Systems
=================

* mobile
    * [[android]]
    * [[ios]]
* desktop
    * [[linux]]
    * [[macos]]
    * [[windows]]
* server
    * [[linux]]
* other
    * [[experimental-operating-systems]]
    * [[web-operating-systems]]
* [[history-of-operating-systems]]
    * dos and amigaos
* Abstraction layers
    * [[virtualisation]]
    * [[containerisation]]
    * [[translation-layer]]
* [[boot]]
* [[ecosystems]]
* [[file-systems]]
* [[kernel]]
    * process scheduling
        * [A complete guide to Linux process scheduling](https://trepo.tuni.fi/bitstream/handle/10024/96864/GRADU-1428493916.pdf) Nikita Ishkov 2015
* [[posix]] unix
    * [The Elephant in the Room - It's time to get the POSIX elephant off our necks.](https://queue.acm.org/detail.cfm?id=3570921)
        * posix is underneath everything
        * Old system == limited RAM + unreliable secondary storage + single processor
        * Modern system == multiple processors, huge RAM, secondary storage reliable, Layers of storage (network, spinning, ssd, nvme, ram, cache)

* [Operating Systems: Three Easy Pieces](https://pages.cs.wisc.edu/~remzi/OSTEP/) free ebook 2021
    * virtualization, concurrency, and persistence
* [intermezzOS](http://intermezzos.github.io/)
    * intermezzOS is a teaching operating system, specifically focused on introducing systems programming concepts to experienced developers from other areas of programming


* [Bring back the ease of 80s and 90s personal computing](https://medium.com/@probonopd/bring-back-the-ease-of-80s-and-90s-personal-computing-393738c5e2a1)
    * Modern OS's are too complex
    * Constantly writing state to system drives
    * Couple to physical drive
    * Multiboot a problem
    * Applications and OS mixed together
    * Applications as one folder
    * Mutiple versions of an application useable
    * No passwords by default
    * Offline by default
* [End User Programming](https://www.inkandswitch.com/end-user-programming.html)
    * > Todayâ€™s software apps are like appliances: we can only use the capabilities exactly as programmed by the developer. What if we, and all computer users, could reach in and modify our favorite apps? Or even create new apps on the fly according to our needs in the moment?
    * > despite forty years of commercial products, open source, and deep academic work, we have yet to reach an end-user programming utopia. In fact, the opposite: today our computing devices are less programmable and less customizable than ever before.


* [The Future of Computers: The Neighborhood and The Nursing Home](https://puri.sm/posts/the-future-of-computers-the-neighborhood-and-the-nursing-home/)
    * Good analogy about modern computers (Apple, Google) created "gated communities and nursing homes" [[privacy]]

* [Ask HN: Where can I find a primer on how computers boot?](https://news.ycombinator.com/item?id=35229045)
    * MIT Open Courseware [Operating System Engineering](https://ocw.mit.edu/courses/6-828-operating-system-engineering-fall-2012/pages/lecture-notes-and-readings/)
        * Virtual memory, interrupts, multiprocessors, file systems, sleep and wake

[//begin]: # "Autogenerated link references for markdown compatibility"
[android]: android.md "Android"
[ios]: ios.md "iOS"
[linux]: linux.md "Linux"
[macos]: macos.md "MacOS"
[windows]: windows.md "Windows"
[experimental-operating-systems]: experimental-operating-systems.md "experimental-operating-systems"
[web-operating-systems]: web-operating-systems.md "web-operating-systems"
[history-of-operating-systems]: history-of-operating-systems.md "History of Operating Systems"
[virtualisation]: virtualisation.md "Virtualisation"
[containerisation]: containerisation.md "Containerisation"
[translation-layer]: translation-layer.md "translation-layer"
[boot]: boot.md "Boot - System Startup"
[ecosystems]: ecosystems.md "desktop ecosystems"
[file-systems]: file-systems.md "File Systems"
[kernel]: kernel.md "Kernel"
[privacy]: privacy.md "Privacy"
[//end]: # "Autogenerated link references"
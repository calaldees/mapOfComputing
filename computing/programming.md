Programming
===========

* [Large Language Models and The End of Programming - CS50 Tech Talk with Dr. Matt Welsh](https://youtu.be/JhCl-GeT4jw?si=aVLFVyg2zaTihslA&t=180) YouTube 1hour
    * > We've been trying to make programming easier for 50 years - It's not got easier - Humans suck at this
    * Conways Game of life in -> Fortran 1957 -> Basic 1964 -> APL 1966 (special keyboard) -> Rust 2010 (State of the art) (it's still HARD!)
    * Nobody can write an algorithm for "Summarise a Podcast"
    * Instructing the model is similar to coding - trial some things
    * We are not at a point where we can give language instruction and understand them ... programming is dead
    * Programmer without co-pilot in 2020 (caveman) -> 2021 CoPilot is a gamechanger
    * Breaking off to StackOverflow and finding the best solution get's you out of the zone of solving your problem
    * https://allpoetry.com/poem/14374597-The-Homework-Machine-by-Shel-Silverstein
    * Average professional programmer outputs 100 lines of code a day and (for everything - costs $1200) - GTP tokens are 100 times cheaper
    * Robot makes mistakes - but they make them VERY quickly
    * No need to have abstractions (and refining these) or intermediates.
    * How do we get the computer to do what we want it to do - how do we prompt/use the models? refine them?
        * "Let's think step by step" was a magic phrase for a model prompt - why? - we don't know - teaching the models is going to be a new discipline
    * New computational architecture
        * https://www.fixie.ai/ (build apps with ai)
            * ai.jsx (to map plain english/react to link to llm) - composing operations is natural thing
            * voice as communications (not typing)
    * Expands "Programming" to the entire population

* [[languages]]
* [[frameworks]]
* [[competitions]]
* [[cache]]
* [[compiler]]
* [[data-structures]]
* [[debugging]]
* [[deprecation]]
* [[program-design]]
* [[encoding]]
* [[example-development]]
* [[functional]]
* [[state]]
* [[interpereter]]
* [[language-edge-cases]]
* [[standard-library]]
* [[librarys]]
* [[object-orientation]]
* [[regex]]
* [[learning-to-code]]
* [[interview]]

* [How principled coders outperform the competition](https://www.youtube.com/watch?v=q1qKv5TBaOA) 10min YouTube Coderized
    * [[styleguide]]
    * [[solid]]
    * [[design-patterns]]
    * Naming
    * [[testing]]
    * [[software-engineering]] time management
    * > Any fool can write code that a computer can understand. Good programmers write code that humans can understand <sub>Martin Fowler</sub>

* [literate programming](http://literateprogramming.com/)
    * [[knuth]] says programs should describe themselfs
    * [[python]] kind of has some of these concepts in doctests

* [Essays on programming I think about a lot](https://www.benkuhn.net/progessays/)
    * Computers can be understood
    * Choose Boring Technology
    * The Wrong Abstraction
    * Falsehoods Programmers Believe About Names
    * The Hiring Post
    * The Product-Minded Engineer
    * Write code that is easy to delete, not easy to extend
    * Repeat yourself, do more than one thing, and rewrite everything
    * The Law of Leaky Abstractions
    * Reflections on software performance
    * Building Robust Systems with ACID and Constraints, Using Atomic Transactions to Power an Idempotent API, Transactionally Staged Job Drains in Postgres, Implementing Stripe-like Idempotency Keys in Postgres.
    * Notes on Distributed Systems for Young Bloods
    * End-to-End Arguments in System Design
    * Inventing on Principle

* [22 YouTube Channels To Level Up Your Programming Skills](https://blog.codegiant.io/programming-skills-d77d4abdf255) - more of an overall guide about how to become a dev

* [#1 Thing to Learn to Become a Self-Taught Programmer](https://youtu.be/sYjEzOIa5JI?t=83) - Your knowledge of the syntax wont get you the job. The ability to produce a desired outcome will.

* [Teach Yourself Programming in Ten Years](https://norvig.com/21-days.html#answers) - Why is everyone in such a rush?

* [8-Bits of Advice for New Programmers (The stuff they don't teach you in school!)](https://www.youtube.com/watch?v=vVRCJ52g5m4)
    * fast simple dev environment
    * break the rules (write difficult to maintain code, so you understand when an improvement is made)
    * get it wrong
    * don't listen to the internet
    * get things wrong



[MockMechanics](https://mockmechanics.com/) - Programming with physical objects in 3D sandbox - Java


* [Why Programming is Hard to Fundamentally Improve](https://aidancunniffe.com/why-programming-is-hard-to-fundamentally-improve-4101612d4ad9)
    * Discussion about why we keep using similar tools and not 'super innovating' all the time. A rational perspective. Programmers are not lazy, they are being realistic.



[//begin]: # "Autogenerated link references for markdown compatibility"
[languages]: languages.md "Languages"
[frameworks]: frameworks.md "Frameworks"
[competitions]: competitions.md "competitions"
[cache]: cache.md "cache"
[compiler]: compiler.md "compiler"
[data-structures]: data-structures.md "Data Structures"
[debugging]: debugging.md "Debugging"
[deprecation]: deprecation.md "Deprecation"
[program-design]: program-design.md "Program Design"
[encoding]: encoding.md "Data Encoding"
[example-development]: example-development.md "Examples"
[functional]: functional.md "Functional Programming"
[state]: state.md "state"
[interpereter]: interpereter.md "interpreter"
[language-edge-cases]: language-edge-cases.md "Language Edge Cases"
[standard-library]: standard-library.md "standard-library"
[object-orientation]: object-orientation.md "Object Orientation"
[regex]: regex.md "regex"
[learning-to-code]: learning-to-code.md "Learning Programming"
[interview]: interview.md "Interview Questions"
[styleguide]: styleguide.md "StyleGuide"
[solid]: solid.md "SOLID"
[design-patterns]: design-patterns.md "Design patterns"
[testing]: testing.md "Testing"
[software-engineering]: software-engineering.md "Software Engineering"
[knuth]: knuth.md "Knuth"
[python]: python.md "python3"
[//end]: # "Autogenerated link references"